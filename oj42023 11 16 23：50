#include<stdio.h>
#pragma warning(disable:4996)
int main()
{
	int n, m;
	long long int quesun[101], mubiao[101];
	int i, j = 0, qs = 0;//记录缺损点
	int k = 0, mb = 0;//记录目标点
	long long int hang[150];
	long long int end[150], begin[150];
	int sumqs[150] = { 0 }, summb[150] = { 0 };//一行有多少个缺损点,目标点//
	long long int t = 0, s = 0, u = 0,wzshu=0,wzshu1=0;//用于循环输出//
	long long int qsweizhi[101],mbweizhi[101];//记录缺损点的位置和目标点位置//
	long long int weizhi;
	long long int zhan[150];//构建一个栈用于输出//
	long long int qsshu[150][100] = { 0 };
	scanf("%d%d", &n, &m);
	for (i = 0; i < n; i++)
		scanf("%lld", &quesun[i]);
	for (i = 0; i < m; i++)
		scanf("%lld", &mubiao[i]);
	begin[0] = 1; end[0] = 1; hang[0] = 1;
	for (i = 1; i < 133; i++)//构造一个最大133行的树//
	{
		begin[i] = end[i - 1] + 1;//起始数//
		hang[i] = (hang[i - 1] - sumqs[i - 1]) * 2;//行总元素数//
		end[i] = begin[i] + hang[i] - 1;//末位数//
		for (j = qs; j < n; j++)
		{
			if (quesun[j] <= end[i] && quesun[j] >= begin[i])
			{
				sumqs[i] += 1;				
				qsshu[i][sumqs[i]] = quesun[j];//记录第i行第qs个缺损点//	
				qsweizhi[qs] = quesun[j] - begin[i];//记录第x个缺损点在当行的位置
				qs += 1;//记录找到了第几个缺损点//			
			}
			else
				break;
		}//找缺损点的函数//
		for (k = mb; k < m; k++)
		{
			if (mubiao[k] <= end[i] && mubiao[k] >= begin[i])
			{
				summb[i] += 1;
				mb += 1;
				mbweizhi[k] = mubiao[k] - begin[i];//记录目标点的位置//
				weizhi = mbweizhi[k];
				for (t = i; t >= 0; t++)
				{
					zhan[t] = begin[t]+weizhi;
					weizhi = weizhi / 2 + 1;
					//以下去找第weizhi个不是缺损点的数//
					u = 0; wzshu = 0; wzshu1 = 0;
					for (s = begin[t]; s < end[t]; s++)
					{
						if (wzshu == weizhi)
						{
							zhan[t] = begin[t]+wzshu1;
						}
						if (s != qsshu[t][u])
							wzshu += 1;
						else
						{
							u += 1;
						}
						wzshu1 += 1;
					}
				}
				for (t = 0; t <= i; t++)
					printf("%lld ", zhan[t]);
				printf("\n");
			}
			else
				break;
		}//找目标点并输出的函数//
	}
	return 0;
}
